6.1 堆
练习：
6.1-1:
最多：2^(h+1)-1;最少：2^h
6.1-2:不会
6.1-3：不会
6.1-4：叶节点
6.1-5：是
6.1-6： 不是
6.1-7：不会
6.2 维护堆的性质
维护堆伪代码实现：
heap = [27,17,3,16,13,10,1,5,7,12,4,8,9,0]
i = 2

def MaxHeapify(heap,i):
    heapLenth = len(heap)
    l = 2*i+1
    r = 2*i+2
    largest = i
    if l <= heapLenth-1 and heap[l] > heap[i]:
        largest = l
    if r <= heapLenth-1 and heap[r] > heap[largest]:
        largest = r
    if largest != i:
        heap[i],heap[largest]=heap[largest],heap[i]
        MaxHeapify(heap,largest)

MaxHeapify(heap,i)
print (heap)
练习：
6.2-1：
heap = [27,17,3,16,13,10,1,5,7,12,4,8,9,0]
i = 2

def MaxHeapify(heap,i):
    heapLenth = len(heap)
    l = 2*i+1
    r = 2*i+2
    largest = i
    if l <= heapLenth-1 and heap[l] > heap[i]:
        largest = l
    if r <= heapLenth-1 and heap[r] > heap[largest]:
        largest = r
    if largest != i:
        heap[i],heap[largest]=heap[largest],heap[i]
        MaxHeapify(heap,largest)

MaxHeapify(heap,i)
print (heap)
6.2-2:
heap = [27,17,30,16,13,10,1,5,7,12,4,8,9,0]
i = 2

def MinHeapify(heap,i):
    heapLenth = len(heap)
    l = 2*i+1
    r = 2*i+2
    smallest = i
    if l <= heapLenth-1 and heap[l] < heap[i]:
        smallest = l
    if r <= heapLenth-1 and heap[r] < heap[smallest]:
        smallest = r
    if smallest != i:
        heap[i],heap[smallest]=heap[smallest],heap[i]
        MinHeapify(heap,smallest)

MinHeapify(heap,i)
print (heap)
6.2-3:代码只能将i向下调整，不能将其向上调节到根节点。
6.2-4：i>A.heap-size/2时，A[i]是叶节点，不会有变化。
6.2-5：
heap = [27,17,3,16,13,10,1,5,7,12,4,8,9,0]
i = 2

def MaxHeapify(heap,i):
    heapLenth = len(heap)
    large = i
    l = 2*large+1
    r = 2*large+2
    if l > heapLenth-1:return 
    if r > heapLenth-1:
        if heap[large] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
        return
    while heap[large] < heap[l] or heap[large] < heap[r]:
        if heap[r] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
            large = l 
        elif heap[l] <= heap[r]:
            heap[large],heap[r]=heap[r],heap[large]
            large = r
        l = 2*large+1
        r = 2*large+2
        if l > heapLenth-1 or r > heapLenth-1:break
            
MaxHeapify(heap,i)
print (heap)
6.2-6:不会
6.3 建堆
建堆伪代码实现：
A = [5,3,17,10,84,19,6,22,9]

def MaxHeapify(heap,i):
    heapLenth = len(heap)
    large = i
    l = 2*large+1
    r = 2*large+2
    if l > heapLenth-1:return 
    if r > heapLenth-1:
        if heap[large] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
        return
    while heap[large] < heap[l] or heap[large] < heap[r]:
        if heap[r] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
            large = l 
        elif heap[l] <= heap[r]:
            heap[large],heap[r]=heap[r],heap[large]
            large = r
        l = 2*large+1
        r = 2*large+2
        if l > heapLenth-1 or r > heapLenth-1:break

def BuildMaxHeap(heap):
    for i in range((len(heap)//2-1),-1,-1):
        MaxHeapify(heap,i)

BuildMaxHeap(A)
print(A)
练习：
6.3-1:
A = [5,3,17,10,84,19,6,22,9]

def MaxHeapify(heap,i):
    heapLenth = len(heap)
    large = i
    l = 2*large+1
    r = 2*large+2
    if l > heapLenth-1:return 
    if r > heapLenth-1:
        if heap[large] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
        return
    while heap[large] < heap[l] or heap[large] < heap[r]:
        if heap[r] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
            large = l 
        elif heap[l] <= heap[r]:
            heap[large],heap[r]=heap[r],heap[large]
            large = r
        l = 2*large+1
        r = 2*large+2
        if l > heapLenth-1 or r > heapLenth-1:break

def BuildMaxHeap(heap):
    for i in range((len(heap)//2-1),-1,-1):
        MaxHeapify(heap,i)

BuildMaxHeap(A)
print(A)
6.3-2:保持由下至上得保持最大堆的性质。
6.3-3：不会
6.4 堆排序算法
堆排序伪代码实现：
A = [5,13,2,25,7,17,20,8,4]

def MaxHeapify(heap,i):
    heapLenth = len(heap)
    large = i
    l = 2*large+1
    r = 2*large+2
    if l > heapLenth-1:return 
    if r > heapLenth-1:
        if heap[large] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
        return
    while heap[large] < heap[l] or heap[large] < heap[r]:
        if heap[r] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
            large = l 
        elif heap[l] <= heap[r]:
            heap[large],heap[r]=heap[r],heap[large]
            large = r
        l = 2*large+1
        r = 2*large+2
        if l > heapLenth-1 or r > heapLenth-1:break

def BuildMaxHeap(heap):
    for i in range((len(heap)//2-1),-1,-1):
        MaxHeapify(heap,i)
        
def HeapSort(heap):
    BuildMaxHeap(heap)
    heapSort = []
    for i in range((len(heap)-1),-1,-1):
        heap[0],heap[i]=heap[i],heap[0]
        heapSort.insert(0,heap.pop())
        MaxHeapify(heap,0)
    return heapSort
    
print ( HeapSort(A))
练习：
6.4-1：
A = [5,13,2,25,7,17,20,8,4]

def MaxHeapify(heap,i):
    heapLenth = len(heap)
    large = i
    l = 2*large+1
    r = 2*large+2
    if l > heapLenth-1:return 
    if r > heapLenth-1:
        if heap[large] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
        return
    while heap[large] < heap[l] or heap[large] < heap[r]:
        if heap[r] < heap[l]:
            heap[large],heap[l]=heap[l],heap[large]
            large = l 
        elif heap[l] <= heap[r]:
            heap[large],heap[r]=heap[r],heap[large]
            large = r
        l = 2*large+1
        r = 2*large+2
        if l > heapLenth-1 or r > heapLenth-1:break

def BuildMaxHeap(heap):
    for i in range((len(heap)//2-1),-1,-1):
        MaxHeapify(heap,i)
        
def HeapSort(heap):
    BuildMaxHeap(heap)
    heapSort = []
    for i in range((len(heap)-1),-1,-1):
        heap[0],heap[i]=heap[i],heap[0]
        heapSort.insert(0,heap.pop())
        MaxHeapify(heap,0)
    return heapSort
    
print ( HeapSort(A))
6.4-2:不会
6.4-3:不会
6.4-4：不会
6.4-5：不会
6.5 优先队列


